Реализация Тестового задания для Junior Unity разработчиков.

Механика Drag-and-Drop:
Я реализовал механику Drag-and-Drop таким образом:

1) Хватание Предметов

    Хватание Предметов было реализовано с помощью обратки нажатий на экран с помощью GetTouch от Input системы в Unity. При нажатии проверяется, с помощью Physics2D.OverlapPoint, попадание в коллайдер объекта
   в выбранном физическом слое для предметов, в случае такого попадания, предмет "Подбирается", для дальнейшего перемещения.

2) Перемещение Предметов

   Перемещение Предметов было релизовано, довольно просто, подобранный предмет, перемещается за пальцем, который находится на экране, преобразуя координаты нажатия в мировые с помощью: ScreenToWorldPoint().

3) Выбрасывание Предмета

   Выбрасывание предмета, было реализовано таким образом: При отпускании пальца с экрана, в скрипте выбранного предмета вызывается метод для падения. А именно, данный метод двигает предмет вниз, до targetPosition с учетом массы предмета,
   которая настраивается в префабе каждого предмета, а также с учетом общей силы гравитации, которая настраивается в отдельном ScriptableObject, в папке GameSettings.

   Поиск необходимой точки для падения предмета, для поиска targetPosition, я написал метод, который, в случае если предмет, находится "в руке", тоесть подобран, он вызывает Physics2D.OverlapCircle, с настраиваемыми значения для радиуса обнаружения,
   который, ищет коллайдер оповерхности на которую предмет может упасть, если при первом вызове, в позиции объекта смещенной немного вниз на заданное значение minDistance, поверхность не найдена, то в таком случае, Physics2D.OverlapCircle делает шаг вниз, для поиска поверхности на которую может упаст предмет,
   и так пока данный объект не будет найдет. Таким образом, предмет обнаруживает изначально те поверхности, которые находятся ближе к нему по координате Y, а также, в случае если сразу под ним есть данный объект, то targetPosition выбирается, как позиция предмета + минимальное смещение,
   Настраиваемое в префабе предметов.
   
   Также было реализовано, учет глубины сцены, за счет настройки обработки рендера, тоесть все объекты находящиеся ниже по Y координате, будут рендерится поверх других объектов на том же слое, но выше по Y координате. А также был реализован учет размеров и слоя на предметах,
   для поверхностей. А именно, в префабе, отвечающим за поверхность, котором мы обозначаем поверхность на которую предмет может упасть, есть настройка слоя и размера для предмета, и после попаданию на данную поверхность, предмет может уменьшиться в размерах, а также уйти на слой ниже,
   например для того, чтобы визуально находится внутри коробки, или под столом, например: ![Снимок экрана 2025-01-20 153636](https://github.com/user-attachments/assets/c986f848-7e50-4188-96d1-e553912bc351) ![Снимок экрана 2025-01-20 153707](https://github.com/user-attachments/assets/86a9abe4-c127-4c40-9993-6e74d751ccdc)
![Снимок экрана 2025-01-20 153655](https://github.com/user-attachments/assets/23755307-4c27-4892-a4d4-750505ae004a)

    Это реализовано, за счет того, что при попадании на поверхность с данными заданными значениями, слой предмета, становится ниже, чем слой спрайта который отображается поверх предмета. А в случае "Хватания предмета", слой предмета становится максимальным и он отображается поверх всего в любом случае,
   пока не будет поставлен на определенную поверхность.


Также было реализовано движение камеры по сцене, как в примере.

А именно: В случае, если "рука" пустая и мы не держим предметов, то для скрола сцены, мы используем также нажатия GetTouch, и двигаем сценой после нажатия, примерно как в ScrollView, перемещая камеру на разницу между текущей позицией пальца и позиций нажатия. А в случае, если
мы держим в "руке" какой либо предмет, то перемещения происходит, если мы поднесем палец с предметом, к боковой границе, на заданное расстояние, и в случае приближения пальца к границе, камера двигается в сторону.

Также, в обоих случаях, камера не выходит за заданные границы сцены, границы задаются в инспекторе в скрипте камеры, камера при старте определяет ширину обзора, и не выходит ей за заданные границы. Данные границы, всегда можно изменить в инспекторе, а также скорость движения и силу скролла.

Также из дополнительного: Было реализовано сохранение позиций, размера и слоя предметов. Тоесть, после перезапуска игры, все предметы остаются на позициях, на которых мы их оставили, также в случае, если предмет был "внутри" коробки или под столом например, он там же и останется,
за счет определния стартовой поверхности.
Сохранение было реализовано в json файл, с помощью dictionary в скрипте saveData, который принимает уникальный идентификатор предмета, а также его текущее положение и либо сохраняет, либо обнавляет данные о позиции. А при старте предметы получали сохраненную позицию если она есть.
Позиция сохраняется в момент, когда предмет попадает на определенную поверхность. Также для создания уникального идентификатора был реализован небольшой скрипт, который создавал его с помощью "Guid" и сохранял также в json файл для дальнейшего использования даным предметом, сохранение и создание
идентификатора происходит в скрипте IdItemData.

А также были реализованы небольшие анимации для предметов, с помощью измненеие размера или позиции, специального объекта, в котором находится спрайт предмета. А именно в случае изменение размера, это происходит плавно, в необходимую сторону, а в случае падения, происходит небольшая
анимация отскакивания, с подбрасыванием вверх и опусканием до нужной позиции. Настройки: скорости анимаций или силы подбрасывания происходят в префабах предметов.

Также скрипты данного проекта с кратким описанием их функционала:

  1. CameraMoveController - скрипт движения камерой.

  2. DragController - скрипт управления "Хватанием" и перетаскиванием предметов.

  3. IdItemData - скрипт для создания и сохранения уникального идентификатора для предметов.

  4. ItemController - скрипт с реализацией падения предметов, выбора поверхности для падения, а также с анимациями предметовю

  5. MainGameStats - скрипт ScriptableObject с настройкой силы гравитации для всех предметов. Сам ScriptableObject находится в папке GameSettings.

  6. SaveData - скрипт для сохранение и получения данных о позиции предметов по их ID.

  7. SurfaceStats - скрипт для установки значений передаваемых предмету на данной поверхности, таких как размер и слой.
